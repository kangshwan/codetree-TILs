#include <iostream>
#define MAX_N 1000

using namespace std;

int N;
int DP[MAX_N+1] = {0,0,1,1,};

int main() {
    cin >> N;
    for(int n = 4 ; n <= N ; n++){
        DP[n] = (DP[n-2] + DP[n-3]) % 10007;
    }
    cout << DP[N];
    return 0;
}
/*
DP문제.
N=5일때, DP[5] = 2가 되도록 코드를 작성해야 한다.
그렇다면 DP에 들어가는 값은 N층일 때, 올 수 있는 방법의 수.
DP 0 1 2 3 4 5
vl 0 0 1 1 1 2
DP[0], DP[1]은 한번에 2~3계단을 올라오기 때문에 방법의 수가 0
DP[2]는 올라올 수 있는 경우의 수가 2계단 올라오는 방법 1개.
DP[3]도 DP[2]와 동일하게 3계단 올라오는 방법 1개.
DP[4]의 경우, DP[1]에서 3계단 올라오는 방법, DP[2]에서 2계단 올라오는 방법 두가지를 더하면 된다.
DP[1]까지 갈 수 있는 경우의 수는 0이기 때문에, DP[1]에서 3계단 올라오는 방법도 0.
DP[2]에서 2계단 올라오는 방법은 2계단 올라오는 것 1가지이므로, DP[4] = 1.
DP[5]의 경우 DP[2]에서 3계단 올라오는 방법, DP[3]에서 2계단 올라오는 방법 두가지다.
즉, 다음과 같이 점화식을 작성할 수 있다.
DP[N] = DP[N-2] + DP[N-3], N >= 4
*/